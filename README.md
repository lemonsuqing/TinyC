# TinyC: 一个从零开始的简易 C 语言编译器

欢迎来到 TinyC 项目！这是一个教学驱动的编译器项目，旨在从零开始，一步步构建一个能够将 C 语言的一个极小特性集，编译成可执行 x86-64 汇编代码的编译器。

这个项目不仅仅是代码的堆砌，更是一段充满挑战、调试与成长的旅程。我们通过不断迭代，为编译器赋予新的能力，并在每一次遇到 bug 时，深入学习其背后的编译原理、C 语言特性和底层系统知识 (System V AMD64 ABI)。

## 当前支持的特性

TinyC 编译器目前可以将包含以下特性的 C 源代码，编译成独立的、可在 Linux (x86-64) 上运行的可执行程序：

*   **程序结构**: 支持 `int main()` 及自定义**函数定义**与**函数调用**。
*   **变量管理**: 变量声明、初始化、赋值，以及**指针变量** (`int* p`)。
*   **指针操作**: 支持取地址 (`&x`) 和解引用 (`*p`)，支持通过指针修改内存 (`*p = val`)。
*   **控制流**:
    *   `if ... else ...` 语句。
    *   `while` 循环语句。
    *   `return` 语句。
*   **算术运算**: `+`, `-`, `*`, `/` (支持优先级)。
*   **比较运算**: `==`, `!=`, `<`, `<=`, `>`, `>=`。
*   **一元运算**: 负号 (`-x`), 逻辑非 (`!x`)。

例如，下面的代码现在可以被 TinyC 成功编译并运行：

```C
// 最终支持的 C 语言代码示例
int add(int a, int b) {
    return a + b;
}

int main() {
    int x = 10;
    int ptr = &x;  // 虽然 TinyC 暂时不检查类型，但这存储了地址
    
    *ptr = 0;      // 通过指针修改 x，x 变为 0

    while (x < 5) {
        if (x == 3) {
            x = add(x, 2); // 函数调用
        } else {
            x = x + 1;
        }
    }
    return x; 
    // 预期退出码: 6
}
```

## 项目结构

```Plain
TinyC/
├── Makefile       # 自动化构建与测试脚本
├── src/           # 所有源代码
│   ├── ast.h          # 抽象语法树 (AST) 节点定义
│   ├── lexer.c/.h     # 词法分析器 (Tokenizer/Lexer)
│   ├── parser.c/.h    # 语法分析器 (Parser)
│   ├── codegen.c/.h   # 代码生成器 (Code Generator)
│   └── main.c         # 编译器主入口
└── README.md      # 本文档
```

## 构建与测试

本项目依赖 gcc 进行构建和测试。

### 构建编译器

```Bash
make
```

这将在 bin/ 目录下生成 tinyc 可执行文件。

### 运行自动化测试

```Bash
make test
```

此命令会自动完成以下所有步骤：

1.  使用 tinyc 编译 src/main.c 中硬编码的源代码，生成汇编文件 test/output.s。
2.  使用 gcc 将 output.s 汇编并链接成可执行程序 test/my\_program。
3.  运行 test/my\_program 并检查其退出码是否与 Makefile 中 EXPECTED\_EXIT\_CODE 的值匹配。
4.  报告测试成功或失败。

## 成长与发展历程

这个项目的发展历程，是一部生动的 “编译器养成记”，也是一部精彩的 “Bug 调试史”。每一个 commit 都代表着我们攻克的一个新领域和解决的一个新挑战。

### 万物之始：词法分析 (Init: 简易编译器完成词法分析)

**新能力**: 编译器学会了 “阅读”，能将简单的源代码字符串（如 { 123 }）分解为一个个有意义的 Token（词法单元）。

**核心实现**: 在 main.c 中实现了 get\_next\_token ()。

**遇到的挑战**:

* “使用已释放内存 (Use After Free)”: 第一次遇到了 C 语言的经典陷阱。在 do-while 循环中 free () 掉 token 后，依然在循环条件中访问它，导致无限循环。解决方案：改用更安全的 while (1) 循环结构。
* 内存泄漏：修复了为 token 的 value 分配了内存却没有释放的问题。

### 搭建骨架：引入语法分析 (支持语法分析)

**新能力**: 编译器学会了初步的 “理解”，能将 Token 序列组织成一个有层次结构的抽象语法树 (AST)。

**核心实现**:

* 引入了 parser 和 ast 模块，将项目重构为多文件结构。
* 实现了 Makefile 自动化构建。
* 实现了第一个递归下降解析函数，能够解析 { <number> } 结构。

**遇到的挑战**:

* 链接错误 (undefined reference to ...): 函数在 .c 中定义，但在 .h 中没有声明，导致链接失败。解决方案：理解了 C 语言中函数声明与定义的区别，并在头文件中添加了必要的向前声明 (Forward Declaration)。

### 能力升级：迈向真正的 C 程序 (升级词法分析...)

**新能力**: 词法分析器功能大幅扩展，能够识别 int, main, return, (,), ; 等 Token，为解析一个完整的 C 程序做好了准备。

**遇到的挑战**:

* 无限循环：在 while 循环中，忘记更新循环条件检查的变量，导致逻辑死循环。
* 字符串处理陷阱: strncpy 不会自动添加 \\0，导致 strcmp 行为异常。

### 质的飞跃：代码生成 (生成汇编代码)

**新能力**: 编译器学会了 “说” 一种新的语言 —— 汇编。它能够遍历 AST 并生成等效的 x86-64 汇编代码。

**核心实现**: 创建了 codegen.c 模块，实现了基于 AST 节点的递归代码生成函数。

**遇到的挑战**:

* 链接的幽灵 (\_start 缺失): 使用 -nostdlib 编译生成的汇编代码后，程序因缺少标准库的 \_start 入口点而段错误。解决方案：在代码生成器中自己实现 \_start，从中 call main，并在 main 返回后通过 syscall 正确退出。

### 状态管理：引入变量 (可以识别 int main () { int x = 5; return x; })

**新能力**: 编译器拥有了 “记忆”，能够处理局部变量的声明、初始化和使用。

**核心实现**:

* 在代码生成器中引入了符号表 (Symbol Table) 来跟踪变量。
* 学习并实现了函数栈帧的管理，通过 rbp 偏移来定位局部变量。

**遇到的挑战**:

* CPU 的天条 (栈对齐): 程序因违反 x86-64 ABI 的 16 字节栈对齐规则而崩溃。解决方案：在分配栈空间时，总是将总大小向上取整到 16 的倍数。
* 内存所有权模型不一致：在语法分析器中混用 strdup 和直接指针传递，导致内存泄漏和难以追踪的崩溃。解决方案：确立了黄金法则：AST 节点永远 “收养” 词法分析器 malloc 的 value 指针，统一了内存管理策略。

### 赋予 “思考”：算术表达式 (实现算术表达式...)

**新能力**: 编译器学会了计算，能够处理 + 和 - 算术运算。

**核心实现**:

* 重构了表达式解析器，引入了多层次的递归下降（expression -> term）来为未来的运算符优先级做准备。
* 在代码生成器中，使用栈 (push/pop) 来保存计算的中间结果。

**遇到的挑战**:

* 汇编操作数类型不匹配：尝试将 64 位寄存器 (rdi) 与 32 位寄存器 (eax) 相加。解决方案：统一使用 64 位寄存器 (rax, rdi) 进行计算。

### 赋予 “智慧”：if 控制流 (实现 if 控制流语句)

**新能力**: 编译器学会了决策，能够理解并实现 if 条件判断语句。

**核心实现**:

* 语法分析器能够解析 if (condition) statement 结构。
* 代码生成器使用标签 (Label) 和条件跳转指令 (cmp, jle) 来实现控制流的转移。

**遇到的挑战**:

* 关键字识别遗漏：忘记将 "if" 添加到词法分析器的关键字列表中，导致它被错误地识别为普通标识符。
* 特殊操作符处理：赋值操作 = 在语法树上被建模为二元操作，但在代码生成时需要与 +, -, > 等计算 / 比较型操作区别对待。解决方案：在 codegen\_binary\_op 中为 TOKEN\_ASSIGN 添加了特殊的处理分支。

### 逻辑的完备：分支与循环 (支持 if-else 与 while)

**新能力**: 编译器学会了更复杂的逻辑控制，不再是一条路走到黑。支持了 `else` 分支处理双路逻辑，以及 `while` 循环处理重复任务。

**核心实现**:
*   `Parser`: 解析 `if-else` 和 `while` 语法结构。
*   `Codegen`: 使用 Label（标签）和跳转指令 (`jmp`, `je`) 构建控制流图。对于 `while`，实现了“条件检查 -> 执行体 -> 跳回开始”的闭环。

**遇到的挑战**:
*   **标签地狱**: 随着控制流嵌套（如 while 里套 if），标签的管理变得复杂。解决方案：使用全局计数器生成唯一的 `_L_start_N`, `_L_end_N` 标签，确保跳转地址不冲突。

### 算术升级：乘除法与优先级 (支持 * /)

**新能力**: 摆脱了只有加减法的“小学生”阶段，支持乘法 `*` 和除法 `/`，并正确处理了运算符优先级（乘除优于加减）。

**核心实现**:
*   `Parser`: 引入 `parse_term` (处理乘除) 和 `parse_expression` (处理加减) 的分层设计，利用递归下降天然实现优先级。
*   `Codegen`: 使用 `imul` (有符号乘法) 和 `idiv` (有符号除法)。

**遇到的挑战**:
*   **x86 除法的怪癖**: `idiv` 指令要求被除数是 128 位的 (`rdx:rax`)。我们只有 64 位的 `rax`。解决方案：在 `idiv` 前使用 `cqo` 指令，将 `rax` 的符号位扩展到 `rdx` 中，否则除法会由于 `rdx` 中的垃圾值导致算术异常 (Floating point exception)。

### 逻辑运算与布尔值 (完善逻辑比较与布尔值)

**新能力**: 支持完整的比较操作符 (`==`, `!=`, `<=`, `>=`)，为 `if` 和 `while` 提供了更精确的判断条件。

**核心实现**:
*   `Codegen`: 使用 `cmp` 指令更新 CPU 标志位，配合 `setcc` (如 `sete`, `setl`) 指令将标志位转换为字节值 (0 或 1)。
*   **关键一步**: `setcc` 只影响 8 位的 `al` 寄存器，必须使用 `movzb` 将其零扩展为 64 位的 `rax`，确保后续计算正确。

### 负重前行：一元运算符 (支持 -x, !x)

**新能力**: 支持负数和逻辑非操作。

**核心实现**:
*   `Parser`: 在 `parse_factor` 之前增加 `parse_unary` 层级，支持递归解析（如 `!!x`）。
*   `Codegen`: 使用 `neg` 指令处理负号；通过“比较是否为0”来实现逻辑非。

### 沟通的桥梁：函数调用 (支持函数调用)

**新能力**: 程序模块化的基石。编译器现在支持定义多个函数，并进行相互调用和参数传递。

**核心实现**:
*   遵循 **System V AMD64 ABI** 调用约定。
*   **传参**: 前 6 个参数依次放入 `rdi`, `rsi`, `rdx`, `rcx`, `r8`, `r9` 寄存器。
*   **保存现场**: 在计算参数时，使用栈 (`push`/`pop`) 保存中间结果，防止寄存器冲突（Register Spilling 的简化版）。

**遇到的挑战**:
*   **参数求值顺序与寄存器冲突**: 如果计算第二个参数时用到了 `rax`，会覆盖第一个参数的结果。解决方案：每计算完一个参数就 `push` 到栈上，所有参数计算完后，再反向 `pop` 到对应的 ABI 寄存器中。

### 内存的掌控者：指针 (支持指针)

**新能力**: C 语言的灵魂。编译器现在支持取地址 `&` 和解引用 `*`，实现了直接内存访问。

**核心实现**:
*   **左值 (L-value) 生成**: 区分“计算值”和“计算地址”。引入 `gen_lvalue` 函数，专门用于赋值号左边的场景。
*   对于 `x = ...`，`gen_lvalue` 使用 `lea` 计算栈偏移地址。
*   对于 `*p = ...`，`gen_lvalue` 先计算 `p` 的值（即目标地址），直接将其作为写入目标。

**遇到的挑战**:
*   **左值与右值的思维转换**: `*p` 在赋值号左边时代表“往哪里写”，在右边时代表“读什么值”。解决方案：在 `codegen_binary_op` (处理赋值) 和 `codegen_unary_op` (处理解引用) 中分别处理这两种逻辑。`*p = ...` 不会生成 load 指令，而是直接使用地址；而 `y = *p` 则会生成 `mov rax, [rax]` 进行内存读取。

### 走出栈帧：全局变量 (Global Variables)
*   **新能力**: 支持在函数外部定义变量，使其生命周期贯穿整个程序。
*   **技术细节**: 
    *   在汇编中引入 `.data` 段来存储全局数据。
    *   代码生成时，实现了作用域查找逻辑：优先查找栈上的局部变量 (`[rbp-N]`)，未找到则使用 RIP 相对寻址访问全局变量 (`[rip+Label]`)。

### 聚合数据：数组 (Arrays)
*   **新能力**: 支持栈上的一维数组声明与访问 (`int a[10]; a[i] = x;`)。
*   **技术细节**:
    *   **空间分配**: 声明数组时，在栈帧中一次性预留 `size * 8` 字节的空间。
    *   **地址计算**: 实现了 `base_addr + index * element_size` 的汇编计算逻辑，支持变量作为索引。

### 沟通世界：字符串与标准库 (Strings & Libc)
*   **新能力**: 实现了字符串字面量 (`"Hello World"`) 的解析与存储，并成功链接 C 标准库 (`libc`)，实现了 `printf` 等外部函数的调用。
*   **核心实现**:
    *   **字符串池 (String Pool)**: 在代码生成阶段收集所有字符串字面量，并统一放入汇编的 `.rodata` (只读数据) 段，通过 `.LCn` 标签引用。
    *   **ABI 兼容性**: 遵循 System V AMD64 ABI，在调用变长参数函数 (如 `printf`) 前，将 `rax` 寄存器清零（用于指示向量寄存器数量）。
    *   **链接重构**: 移除了手写的 `_start` 入口，改用 `main` 作为入口，利用 GCC/LD 的标准链接流程来引入 `libc`。