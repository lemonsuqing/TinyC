# TinyC: 一个从零开始的简易 C 语言编译器

欢迎来到 TinyC 项目！这是一个教学驱动的编译器项目，旨在从零开始，一步步构建一个能够将 C 语言的一个极小特性集，编译成可执行 x86-64 汇编代码的编译器。

这个项目不仅仅是代码的堆砌，更是一段充满挑战、调试与成长的旅程。我们通过不断迭代，为编译器赋予新的能力，并在每一次遇到 bug 时，深入学习其背后的编译原理、C 语言特性和底层系统知识。

## 当前支持的特性

TinyC 编译器目前可以将包含以下特性的 C 源代码，编译成独立的、可在 Linux (x86-64) 上运行的可执行程序：

* **函数定义**: 仅支持 `int main()`。
* **返回语句**: `return <expression>;`
* **变量声明与初始化**: `int <var> = <value>;`
* **变量赋值**: `<var> = <value>;`
* **算术表达式**: 支持 `+` 和 `-`。
* **比较表达式**: 支持 `>`。
* **`if`**** 控制流**: 支持不带 `else` 的 `if (condition) <statement>` 结构。

例如，下面的代码可以被 TinyC 成功编译并运行：

```C
// 最终支持的 C 语言代码示例
int main() {
    int x = 3;
    if (x > 2) {
        x = x + 2;
    }
    return x; 
    // 预期退出码: 5
}
```

## 项目结构

```Plain
TinyC/
├── Makefile       # 自动化构建与测试脚本
├── src/           # 所有源代码
│   ├── ast.h          # 抽象语法树 (AST) 节点定义
│   ├── lexer.c/.h     # 词法分析器 (Tokenizer/Lexer)
│   ├── parser.c/.h    # 语法分析器 (Parser)
│   ├── codegen.c/.h   # 代码生成器 (Code Generator)
│   └── main.c         # 编译器主入口
└── README.md      # 本文档
```

## 构建与测试

本项目依赖 gcc 进行构建和测试。

### 构建编译器

```Bash
make
```

这将在 bin/ 目录下生成 tinyc 可执行文件。

### 运行自动化测试

```Bash
make test
```

此命令会自动完成以下所有步骤：

1. 使用 tinyc 编译 src/main.c 中硬编码的源代码，生成汇编文件 test/output.s。
2. 使用 gcc 将 output.s 汇编并链接成可执行程序 test/my\_program。
3. 运行 test/my\_program 并检查其退出码是否与 Makefile 中 EXPECTED\_EXIT\_CODE 的值匹配。
4. 报告测试成功或失败。

## 成长与发展历程

这个项目的发展历程，是一部生动的 “编译器养成记”，也是一部精彩的 “Bug 调试史”。每一个 commit 都代表着我们攻克的一个新领域和解决的一个新挑战。

### 万物之始：词法分析 (Init: 简易编译器完成词法分析)

**新能力**: 编译器学会了 “阅读”，能将简单的源代码字符串（如 { 123 }）分解为一个个有意义的 Token（词法单元）。

**核心实现**: 在 main.c 中实现了 get\_next\_token ()。

**遇到的挑战**:

* “使用已释放内存 (Use After Free)”: 第一次遇到了 C 语言的经典陷阱。在 do-while 循环中 free () 掉 token 后，依然在循环条件中访问它，导致无限循环。解决方案：改用更安全的 while (1) 循环结构。
* 内存泄漏：修复了为 token 的 value 分配了内存却没有释放的问题。

### 搭建骨架：引入语法分析 (支持语法分析)

**新能力**: 编译器学会了初步的 “理解”，能将 Token 序列组织成一个有层次结构的抽象语法树 (AST)。

**核心实现**:

* 引入了 parser 和 ast 模块，将项目重构为多文件结构。
* 实现了 Makefile 自动化构建。
* 实现了第一个递归下降解析函数，能够解析 { <number> } 结构。

**遇到的挑战**:

* 链接错误 (undefined reference to ...): 函数在 .c 中定义，但在 .h 中没有声明，导致链接失败。解决方案：理解了 C 语言中函数声明与定义的区别，并在头文件中添加了必要的向前声明 (Forward Declaration)。

### 能力升级：迈向真正的 C 程序 (升级词法分析...)

**新能力**: 词法分析器功能大幅扩展，能够识别 int, main, return, (,), ; 等 Token，为解析一个完整的 C 程序做好了准备。

**遇到的挑战**:

* 无限循环：在 while 循环中，忘记更新循环条件检查的变量，导致逻辑死循环。
* 字符串处理陷阱: strncpy 不会自动添加 \\0，导致 strcmp 行为异常。

### 质的飞跃：代码生成 (生成汇编代码)

**新能力**: 编译器学会了 “说” 一种新的语言 —— 汇编。它能够遍历 AST 并生成等效的 x86-64 汇编代码。

**核心实现**: 创建了 codegen.c 模块，实现了基于 AST 节点的递归代码生成函数。

**遇到的挑战**:

* 链接的幽灵 (\_start 缺失): 使用 -nostdlib 编译生成的汇编代码后，程序因缺少标准库的 \_start 入口点而段错误。解决方案：在代码生成器中自己实现 \_start，从中 call main，并在 main 返回后通过 syscall 正确退出。

### 状态管理：引入变量 (可以识别 int main () { int x = 5; return x; })

**新能力**: 编译器拥有了 “记忆”，能够处理局部变量的声明、初始化和使用。

**核心实现**:

* 在代码生成器中引入了符号表 (Symbol Table) 来跟踪变量。
* 学习并实现了函数栈帧的管理，通过 rbp 偏移来定位局部变量。

**遇到的挑战**:

* CPU 的天条 (栈对齐): 程序因违反 x86-64 ABI 的 16 字节栈对齐规则而崩溃。解决方案：在分配栈空间时，总是将总大小向上取整到 16 的倍数。
* 内存所有权模型不一致：在语法分析器中混用 strdup 和直接指针传递，导致内存泄漏和难以追踪的崩溃。解决方案：确立了黄金法则：AST 节点永远 “收养” 词法分析器 malloc 的 value 指针，统一了内存管理策略。

### 赋予 “思考”：算术表达式 (实现算术表达式...)

**新能力**: 编译器学会了计算，能够处理 + 和 - 算术运算。

**核心实现**:

* 重构了表达式解析器，引入了多层次的递归下降（expression -> term）来为未来的运算符优先级做准备。
* 在代码生成器中，使用栈 (push/pop) 来保存计算的中间结果。

**遇到的挑战**:

* 汇编操作数类型不匹配：尝试将 64 位寄存器 (rdi) 与 32 位寄存器 (eax) 相加。解决方案：统一使用 64 位寄存器 (rax, rdi) 进行计算。

### 赋予 “智慧”：if 控制流 (实现 if 控制流语句)

**新能力**: 编译器学会了决策，能够理解并实现 if 条件判断语句。

**核心实现**:

* 语法分析器能够解析 if (condition) statement 结构。
* 代码生成器使用标签 (Label) 和条件跳转指令 (cmp, jle) 来实现控制流的转移。

**遇到的挑战**:

* 关键字识别遗漏：忘记将 "if" 添加到词法分析器的关键字列表中，导致它被错误地识别为普通标识符。
* 特殊操作符处理：赋值操作 = 在语法树上被建模为二元操作，但在代码生成时需要与 +, -, > 等计算 / 比较型操作区别对待。解决方案：在 codegen\_binary\_op 中为 TOKEN\_ASSIGN 添加了特殊的处理分支。